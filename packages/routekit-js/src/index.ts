import { Routes, FastNode, FlatTree, toFast, toFlat } from "routekit";

export interface JSEmitterOptions {
  target?: "es2015" | "ts";
  mode?: "browser" | "server";
}

export class JSEmitter {
  private options: JSEmitterOptions;

  constructor(private routes: Routes, options?: JSEmitterOptions) {
    this.options = {
      target: "es2015",
      mode: "browser",
      ...options,
    };
  }

  emitDoNotModifyComment(): string {
    let output = "";
    output += "/**\n";
    output += " * DO NOT MODIFY!\n";
    output += " *\n";
    output += " * This file is generated by routekit.\n";
    output += " */\n\n";
    return output;
  }

  emitRoutes(name: string = "ROUTES"): string {
    switch (this.options.mode) {
      case "browser":
        return `export const ${name} = ${emitFlatTree(toFlat(this.routes.root))};`;
      case "server":
        return `export const ${name} = ${emitFastTree(toFast(this.routes.root))};`;
      default:
        throw new Error(`Invalid mode: ${this.options.mode}`);
    }
  }

  emitReverseFunctions(): string {
    const o = this.options;
    const routes = this.routes;

    const reverseFunctions: string[] = [];
    routes.reverse.forEach((path, name) => {
      const params = [];
      const cpath = [];
      let currentStatic = "";
      let catchAllParam = "";

      for (const p of path) {
        if (p[0] === "?") {
          if (currentStatic) {
            cpath.push(`"${currentStatic}"`);
            currentStatic = "";
          }
          const s = p.slice(1);
          cpath.push(s);
          params.push(emitParam(o.target!, s));
        } else if (p[0] === "*") {
          if (currentStatic) {
            cpath.push(`"${currentStatic}"`);
            currentStatic = "";
          }
          const s = p.slice(1);
          catchAllParam = s;
          params.push(emitParam(o.target!, s));
        } else {
          currentStatic += p;
        }
      }
      if (currentStatic) {
        cpath.push(`"${currentStatic}"`);
        currentStatic = "";
      }

      let fn = `export function ${name}(${params.join(", ")}) {\n`;
      if (catchAllParam) {
        fn += `  if (${catchAllParam} === undefined) {\n`;
        fn += `    return ${cpath.join(" + ")}\n`;
        fn += `  }\n`;
        fn += `  return ${cpath.join(" + ")} + ${catchAllParam};\n`;
        fn += `}`;
      } else {
        fn += `  return ${cpath.join(" + ")};\n`;
        fn += "}";
      }
      reverseFunctions.push(fn);
    });

    return reverseFunctions.join("\n\n");
  }

  emitReverseMap(name: string = "REVERSE"): string {
    return `\nexport const ${name} = ${emitReverseMap(this.routes.reverse)};\n`;
  }
}

function emitFlatTree(tree: FlatTree<any>): string {
  let out = "{\n";
  out += "  f:" + JSON.stringify(tree.flags) + ",\n";
  out += "  p:" + JSON.stringify(tree.paths) + ",\n";
  out += "  d:[" + tree.data.join(",") + "],\n";
  out += "}";

  return out;
}

function emitFastTree(n: FastNode<any>, depth = 0): string {
  const props = [];
  switch (n.type) {
    case "s":
      props.push(`${indent(depth + 1)}type: 0`);
      break;
    case "?":
      props.push(`${indent(depth + 1)}type: 1`);
      break;
  }
  props.push(`${indent(depth + 1)}match: ${n.match}`);
  props.push(`${indent(depth + 1)}catchAll: ${n.catchAll}`);
  props.push(`${indent(depth + 1)}path: "${n.path}"`);
  if (n.staticIndices) {
    props.push(`${indent(depth + 1)}staticIndices: ${JSON.stringify(n.staticIndices.map((i) => i.charCodeAt(0)))}`);
  } else {
    props.push(`${indent(depth + 1)}staticIndices: null`);
  }
  if (n.staticChildren) {
    props.push(`${indent(depth + 1)}staticChildren: [`
      + `${n.staticChildren.map((c) => emitFastTree(c, depth + 1)).join(", ")}]`);
  } else {
    props.push(`${indent(depth + 1)}staticChildren: null`);
  }
  if (n.paramChild) {
    props.push(`${indent(depth + 1)}paramChild: ${emitFastTree(n.paramChild, depth + 1)}`);
  } else {
    props.push(`${indent(depth + 1)}paramChild: null`);
  }
  if (n.data) {
    const data = [
      valueOrNull(n.data.connect),
      valueOrNull(n.data.delete),
      valueOrNull(n.data.get),
      valueOrNull(n.data.head),
      valueOrNull(n.data.options),
      valueOrNull(n.data.patch),
      valueOrNull(n.data.post),
      valueOrNull(n.data.put),
      valueOrNull(n.data.trace),
    ];
    while (data.length && data[data.length - 1] === null) {
      data.pop();
    }
    let dataOut = "[\n";
    for (const d of data) {
      dataOut += `${indent(depth + 2)}${d},\n`;
    }
    dataOut += `${indent(depth + 1)}]`;

    props.push(`${indent(depth + 1)}data: ${dataOut}`);
  } else {
    props.push(`${indent(depth + 1)}data: null`);
  }

  let out = "";
  out += "{\n";
  out += props.join(",\n") + "\n";
  out += indent(depth) + "}";

  return out;
}

function emitReverseMap(reverse: Map<string, string[]>): string {
  return "{\n" + Array.from(reverse.keys()).map((n) => `  "${n}": ${n}`).join(",\n") + "\n}";
}

const _indentStrings: string[] = [];

function indent(n: number): string {
  if (n < _indentStrings.length) {
    return _indentStrings[n];
  }

  let s = "";
  while (n-- > 0) {
    s += "  ";
  }

  return _indentStrings[n] = s;
}

function valueOrNull<T>(value: T | undefined): T | null {
  return value === undefined ? null : value;
}

function emitParam(target: "es2015" | "ts", p: string): string {
  if (target === "es2015") {
    return p;
  }
  return `${p}: any`;
}
